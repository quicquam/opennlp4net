using System.Collections.Generic;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using System.Linq;
using j4n.Serialization;


namespace opennlp.tools.parser
{


	using Event = opennlp.model.Event;
	using ChunkerContextGenerator = opennlp.tools.chunker.ChunkerContextGenerator;
	using Dictionary = opennlp.tools.dictionary.Dictionary;
	using Parser = opennlp.tools.parser.chunking.Parser;
	using DefaultPOSContextGenerator = opennlp.tools.postag.DefaultPOSContextGenerator;
	using POSContextGenerator = opennlp.tools.postag.POSContextGenerator;
	using opennlp.tools.util;

	/// <summary>
	/// Abstract class extended by parser event streams which perform tagging and chunking.
	/// </summary>
	public abstract class AbstractParserEventStream : opennlp.tools.util.AbstractEventStream<Parse>
	{

	  private ChunkerContextGenerator chunkerContextGenerator;
	  private POSContextGenerator tagContextGenerator;
	  protected internal HeadRules rules;
	  protected internal HashSet<string> punctSet;

	  /// <summary>
	  /// The type of events being generated by this event stream.
	  /// </summary>
	  protected internal ParserEventTypeEnum etype;
	  protected internal bool fixPossesives;
	  protected internal Dictionary dict;

	  public AbstractParserEventStream(ObjectStream<Parse> d, HeadRules rules, ParserEventTypeEnum etype, Dictionary dict) : base(d)
	  {
		this.dict = dict;
		if (etype == ParserEventTypeEnum.CHUNK)
		{
		  this.chunkerContextGenerator = new ChunkContextGenerator();
		}
		else if (etype == ParserEventTypeEnum.TAG)
		{
		  this.tagContextGenerator = new DefaultPOSContextGenerator(null);
		}
		this.rules = rules;
		punctSet = rules.PunctuationTags;
		this.etype = etype;

		init();
	  }

	  protected internal override IEnumerator<Event> createEvents(Parse sample)
	  {
		IList<Event> newEvents = new List<Event>();

		Parse.pruneParse(sample);
		if (fixPossesives)
		{
		  Parse.fixPossesives(sample);
		}
		sample.updateHeads(rules);
		Parse[] chunks = getInitialChunks(sample);
		if (etype == ParserEventTypeEnum.TAG)
		{
		  addTagEvents(newEvents, chunks);
		}
		else if (etype == ParserEventTypeEnum.CHUNK)
		{
		  addChunkEvents(newEvents, chunks);
		}
		else
		{
		  addParseEvents(newEvents, AbstractBottomUpParser.collapsePunctuation(chunks,punctSet));
		}

		return newEvents.GetEnumerator();
	  }

	  protected internal virtual void init()
	  {
		fixPossesives = false;
	  }

	  public AbstractParserEventStream(ObjectStream<Parse> d, HeadRules rules, ParserEventTypeEnum etype) : this(d,rules,etype,null)
	  {
	  }

	  public static Parse[] getInitialChunks(Parse p)
	  {
		IList<Parse> chunks = new List<Parse>();
		getInitialChunks(p, chunks);
		return chunks.ToArray();
	  }

	  private static void getInitialChunks(Parse p, IList<Parse> ichunks)
	  {
		if (p.PosTag)
		{
		  ichunks.Add(p);
		}
		else
		{
		  Parse[] kids = p.Children;
		  bool allKidsAreTags = true;
		  for (int ci = 0, cl = kids.Length; ci < cl; ci++)
		  {
			if (!kids[ci].PosTag)
			{
			  allKidsAreTags = false;
			  break;
			}
		  }
		  if (allKidsAreTags)
		  {
			ichunks.Add(p);
		  }
		  else
		  {
			for (int ci = 0, cl = kids.Length; ci < cl; ci++)
			{
			  getInitialChunks(kids[ci], ichunks);
			}
		  }
		}
	  }

	  /// <summary>
	  /// Produces all events for the specified sentence chunks
	  /// and adds them to the specified list. </summary>
	  /// <param name="newEvents"> A list of events to be added to. </param>
	  /// <param name="chunks"> Pre-chunked constituents of a sentence. </param>
	  protected internal abstract void addParseEvents(IList<Event> newEvents, Parse[] chunks);

	  private void addChunkEvents(IList<Event> chunkEvents, Parse[] chunks)
	  {
		IList<string> toks = new List<string>();
		IList<string> tags = new List<string>();
		IList<string> preds = new List<string>();
		for (int ci = 0, cl = chunks.Length; ci < cl; ci++)
		{
		  Parse c = chunks[ci];
		  if (c.PosTag)
		  {
			toks.Add(c.CoveredText);
			tags.Add(c.Type);
			preds.Add(AbstractBottomUpParser.OTHER);
		  }
		  else
		  {
			bool start = true;
			string ctype = c.Type;
			Parse[] kids = c.Children;
			for (int ti = 0,tl = kids.Length;ti < tl;ti++)
			{
			  Parse tok = kids[ti];
			  toks.Add(tok.CoveredText);
			  tags.Add(tok.Type);
			  if (start)
			  {
				preds.Add(AbstractBottomUpParser.START + ctype);
				start = false;
			  }
			  else
			  {
                  preds.Add(AbstractBottomUpParser.CONT + ctype);
			  }
			}
		  }
		}
		for (int ti = 0, tl = toks.Count; ti < tl; ti++)
		{
		  chunkEvents.Add(new Event(preds[ti], chunkerContextGenerator.getContext(ti, toks.ToArray(), tags.ToArray(), preds.ToArray())));
		}
	  }

	  private void addTagEvents(IList<Event> tagEvents, Parse[] chunks)
	  {
		IList<string> toks = new List<string>();
		IList<string> preds = new List<string>();
		for (int ci = 0, cl = chunks.Length; ci < cl; ci++)
		{
		  Parse c = chunks[ci];
		  if (c.PosTag)
		  {
			toks.Add(c.CoveredText);
			preds.Add(c.Type);
		  }
		  else
		  {
			Parse[] kids = c.Children;
			for (int ti = 0,tl = kids.Length;ti < tl;ti++)
			{
			  Parse tok = kids[ti];
			  toks.Add(tok.CoveredText);
			  preds.Add(tok.Type);
			}
		  }
		}
		for (int ti = 0, tl = toks.Count; ti < tl; ti++)
		{
		  tagEvents.Add(new Event(preds[ti], tagContextGenerator.getContext(ti, toks.ToArray(), preds.ToArray(), null)));
		}
	  }

	  /// <summary>
	  /// Returns true if the specified child is the last child of the specified parent. </summary>
	  /// <param name="child"> The child parse. </param>
	  /// <param name="parent"> The parent parse. </param>
	  /// <returns> true if the specified child is the last child of the specified parent; false otherwise. </returns>
	  protected internal virtual bool lastChild(Parse child, Parse parent)
	  {
		Parse[] kids = AbstractBottomUpParser.collapsePunctuation(parent.Children,punctSet);
		return (kids[kids.Length - 1] == child);
	  }

	}

}